import libjevois as jevois #type:ignore
import cv2
import numpy as np
import math
import re
import cv2
import numpy
from enum import Enum

class PipelineHull:
    """
    An OpenCV pipeline generated by GRIP.
    """
    
    def __init__(self):
        """initializes all values to presets or None if need to be set
        """

        self.__hsv_threshold_hue = [16.18705035971223, 81.70648464163823]
        self.__hsv_threshold_saturation = [84.84712230215827, 255.0]
        self.__hsv_threshold_value = [114.65827338129496, 255.0]

        self.hsv_threshold_output = None

        self.__blur_input = self.hsv_threshold_output
        self.__blur_type = BlurType.Median_Filter
        self.__blur_radius = 20.72072072072072

        self.blur_output = None

        self.__cv_canny_image = self.blur_output
        self.__cv_canny_threshold1 = 0.0
        self.__cv_canny_threshold2 = 0.0
        self.__cv_canny_aperturesize = 3.0
        self.__cv_canny_l2gradient = False

        self.cv_canny_output = None

        self.__find_contours_input = self.cv_canny_output
        self.__find_contours_external_only = True

        self.find_contours_output = None

        self.__convex_hulls_contours = self.find_contours_output

        self.convex_hulls_output = None


    def process(self, source0):
        """
        Runs the pipeline and sets all outputs to new values.
        """
        #Step CircularMask
        source0 = self.circularmask(source0)
        # Step HSV_Threshold0:
        self.__hsv_threshold_input = source0
        (self.hsv_threshold_output) = self.__hsv_threshold(self.__hsv_threshold_input, self.__hsv_threshold_hue, self.__hsv_threshold_saturation, self.__hsv_threshold_value)

        # Step Blur0:
        self.__blur_input = self.hsv_threshold_output
        (self.blur_output) = self.__blur(self.__blur_input, self.__blur_type, self.__blur_radius)

        # Step CV_Canny0:
        self.__cv_canny_image = self.blur_output
        (self.cv_canny_output) = self.__cv_canny(self.__cv_canny_image, self.__cv_canny_threshold1, self.__cv_canny_threshold2, self.__cv_canny_aperturesize, self.__cv_canny_l2gradient)

        # Step Find_Contours0:
        self.__find_contours_input = self.cv_canny_output
        (self.__find_contours_output) = self.__find_contours(self.__find_contours_input, self.__find_contours_external_only)

        #Step find biggestContor
        self.__biggest_contour=self.find_biggest_contour(self.__find_contours_output)

    
        # Step Convex_Hulls0:
         
        (self.__convex_biggest_contour) = self.__convex_hulls(self.__biggest_contour)

    @staticmethod
    def circularmask(img):
        radius2 = 175
        ww, hh, _ = img.shape
        xc = hh // 2
        yc = ww // 2  
        mask2 = np.zeros_like(img)
        mask = cv2.circle(mask2, (xc,yc), radius2, (255,255,255), -1)
        dst = cv2.bitwise_and(img, mask2)

    @staticmethod
    def __hsv_threshold(input, hue, sat, val):
        """Segment an image based on hue, saturation, and value ranges.
        Args:
            input: A BGR numpy.ndarray.
            hue: A list of two numbers the are the min and max hue.
            sat: A list of two numbers the are the min and max saturation.
            lum: A list of two numbers the are the min and max value.
        Returns:
            A black and white numpy.ndarray.
        """
        out = cv2.cvtColor(input, cv2.COLOR_BGR2HSV)
        return cv2.inRange(out, (hue[0], sat[0], val[0]),  (hue[1], sat[1], val[1]))

    @staticmethod
    def __blur(src, type, radius):
        """Softens an image using one of several filters.
        Args:
            src: The source mat (numpy.ndarray).
            type: The blurType to perform represented as an int.
            radius: The radius for the blur as a float.
        Returns:
            A numpy.ndarray that has been blurred.
        """
        if(type is BlurType.Box_Blur):
            ksize = int(2 * round(radius) + 1)
            return cv2.blur(src, (ksize, ksize))
        elif(type is BlurType.Gaussian_Blur):
            ksize = int(6 * round(radius) + 1)
            return cv2.GaussianBlur(src, (ksize, ksize), round(radius))
        elif(type is BlurType.Median_Filter):
            ksize = int(2 * round(radius) + 1)
            return cv2.medianBlur(src, ksize)
        else:
            return cv2.bilateralFilter(src, -1, round(radius), round(radius))

    @staticmethod
    def __cv_canny(image, thres1, thres2, aperture_size, gradient):
        """Applies a canny edge detection to the image.
        Args:
           image: A numpy.ndarray as the input.
           thres1: First threshold for the canny algorithm. (number)
           thres2: Second threshold for the canny algorithm. (number)
           aperture_size: Aperture size for the canny operation. (number)
           gradient: If the L2 norm should be used. (boolean)
        Returns:
            The edges as a numpy.ndarray.
        """
        return cv2.Canny(image, thres1, thres2, apertureSize=(int)(aperture_size),
            L2gradient=gradient)

    @staticmethod
    def __find_contours(input, external_only):
        """Sets the values of pixels in a binary image to their distance to the nearest black pixel.
        Args:
            input: A numpy.ndarray.
            external_only: A boolean. If true only external contours are found.
        Return:
            A list of numpy.ndarray where each one represents a contour.
        """
        if(external_only):
            mode = cv2.RETR_EXTERNAL
        else:
            mode = cv2.RETR_LIST
        method = cv2.CHAIN_APPROX_SIMPLE
        contours, hierarchy = cv2.findContours(input, mode=mode, method=method)
        return contours

    @staticmethod 
    def find_biggest_contour(contours):
        sortedContours = sorted(contours, key=lambda contour: -cv2.contourArea(contour))
        biggest_contour=sortedContours[0]
        return biggest_contour
    
    @staticmethod
    def find_center_draw_contour(frame,biggest_contour):
        
        moments = cv2.moments(biggest_contour)
        if moments['m00'] !=0:
            center=((int(moments['m10']/moments['m00']), int(moments['m01']/moments['m00'])))
            cv2.circle(frame, center, 3, (0, 0, 255), -1)
            return center
        
    @staticmethod
    def __convex_hulls(frame,biggest_contour):
        cv2.drawContours(frame,[biggest_contour],0,(255,0,255),3)
        """Computes the convex hulls of contours.
        Args:
            input_contours: A list of numpy.ndarray that each represent a contour.
        Returns:
            A list of numpy.ndarray that each represent a contour.
        """
        output = cv2.convexHull(biggest_contour)
        return output

BlurType = Enum('BlurType', 'Box_Blur Gaussian_Blur Median_Filter Bilateral_Filter')








def angle_between(p1, p2, p3):
    """Calculate the angle between three points in radians."""
    x1, y1 = p1
    x2, y2 = p2
    x3, y3 = p3
    a = math.sqrt((x2-x1)**2 + (y2-y1)**2)
    b = math.sqrt((x2-x3)**2 + (y2-y3)**2)
    c = math.sqrt((x3-x1)**2 + (y3-y1)**2)
    return math.acos((a**2 + b**2 - c**2) / (2 * a * b))

def smallest_angle_vertex(vertices):
    """Find the vertex with the smallest angle in a polygon."""
    angles = []
    for i in range(len(vertices)):
        p1 = vertices[i-1]
        p2 = vertices[i]
        p3 = vertices[(i+1) % len(vertices)]
        angles.append(angle_between(p1, p2, p3))
    min_angle = min(angles)
    min_index = angles.index(min_angle)
    return vertices[min_index]


pipeline = PipelineHull()

class Orientation:
    # ###################################################################################################
    ## Constructor
    def __init__(self):
        # Instantiate a JeVois Timer to measure our processing framerate:
        self.timer = jevois.Timer("processing timer", 100, jevois.LOG_INFO)
        self.CPULoad_pct = "0"
        self.CPUTemp_C = "0"
        self.pattern = re.compile('([0-9]*\.[0-9]+|[0-9]+) fps, ([0-9]*\.[0-9]+|[0-9]+)% CPU, ([0-9]*\.[0-9]+|[0-9]+)C,')
        self.frame = 0
        self.angle_final = 0

    def find_cube(self,frame):
            mask1 = maskGenerator1(frame)
            contours1=findContours(mask1)   
            #contours1=f.filter_out_contours_that_doesnot_look_like_square(contours1)
            if len(contours1) >0:
                biggest_contour1=find_biggest_contour(contours1)
                center1=find_center_and_draw_center_and_contour_of_target(frame,biggest_contour1)
                area1=cv2.contourArea(biggest_contour1) 
                if area1 >= 1600:
                    self.angle_final = 100
                    return True
            return False
    '''
    def find_cone(self,frame):
        mask2=maskGenerator2(frame,lower_yellow,higher_yellow)
        contours2=findContours(mask2) 
        if len(contours2) >0:
            biggest_contour2=find_biggest_contour(contours2)
            area2=cv2.contourArea(biggest_contour2) 
            if area2 >= 1600:
                center2=find_center_and_draw_center_and_contour_of_target(frame,biggest_contour2)
                point_x2,point_y2=center2
                #cv2.putText(frame,'{}cm,Cone'.format(distance_cm2),(point_x2,point_y2-10),0,1,(0,0,255),2)
                epsilon = 0.05 * cv2.arcLength(biggest_contour2, True)
                approx = cv2.approxPolyDP(biggest_contour2, epsilon, True)
                cv2.polylines(frame, [approx], True, (0, 255, 0), 6)
                cv2.putText(frame,str(len(approx)),(point_x2,point_y2-40),0,1,(255,0,0),2)
            
                points_array=approx.tolist()
                points_tuple=[]#position of the three major points
                for i in points_array:
                    for c in i:
                        c=tuple(c)
                        points_tuple.append(c)
                target_point = smallest_angle_vertex(points_tuple)
                cv2.arrowedLine(frame, center2, target_point,(255,0,0), 9) 
                x_final,y_final=target_point#point_x2,point_y2=center2
                #difine a lower point
                dis_center_to_target=((point_x2-x_final)**2+(point_y2-y_final)**2)**(1/2)
                lower_x=point_x2
                lower_y=point_y2-dis_center_to_target
                dis_target_to_lower=((lower_x-x_final)**2+(lower_y-y_final)**2)**(1/2)
                self.angle_final=math.acos(((dis_center_to_target)**2+(dis_center_to_target)**2-(dis_target_to_lower)**2)/(2*(dis_center_to_target)*(dis_center_to_target)))
                if x_final<point_x2:
                    self.angle_final=(-1)*self.angle_final
                # cv2.arrowedLine(frame, center2, (lower_x,lower_y),(0,0,255), 9) 
                cv2.putText(frame,str(self.angle_final),(point_x2,point_y2-10),0,1,(255,0,0),2)
                return True
        return False
    '''
    def find_cone(self,frame):
        mask2=maskGenerator2(frame,lower_yellow,higher_yellow)
        contours2=findContours(mask2) 
        if len(contours2) >0:
            biggest_contour2=find_biggest_contour(contours2)
            area2=cv2.contourArea(biggest_contour2) 
            if area2 >= 1600:
                center2=find_center_and_draw_center_and_contour_of_target(frame,biggest_contour2)
                point_x2,point_y2=center2
                #cv2.putText(frame,'{}cm,Cone'.format(distance_cm2),(point_x2,point_y2-10),0,1,(0,0,255),2)
                epsilon = 0.05 * cv2.arcLength(biggest_contour2, True)
                approx = cv2.approxPolyDP(biggest_contour2, epsilon, True)
                cv2.polylines(frame, [approx], True, (0, 255, 0), 6)
                cv2.putText(frame,str(len(approx)),(point_x2,point_y2-40),0,1,(255,0,0),2)
            
                points_array=approx.tolist()
                points_tuple=[]#position of the three major points
                for i in points_array:
                    for c in i:
                        c=tuple(c)
                        points_tuple.append(c)
                target_point = smallest_angle_vertex(points_tuple)
                cv2.arrowedLine(frame, center2, target_point,(255,0,0), 9) 
                x_final,y_final=target_point#point_x2,point_y2=center2
                #difine a lower point
                dis_center_to_target=((point_x2-x_final)**2+(point_y2-y_final)**2)**(1/2)
                lower_x=point_x2
                lower_y=point_y2-dis_center_to_target
                dis_target_to_lower=((lower_x-x_final)**2+(lower_y-y_final)**2)**(1/2)
                self.angle_final=math.acos(((dis_center_to_target)**2+(dis_center_to_target)**2-(dis_target_to_lower)**2)/(2*(dis_center_to_target)*(dis_center_to_target)))
                if x_final<point_x2:
                    self.angle_final=(-1)*self.angle_final
                # cv2.arrowedLine(frame, center2, (lower_x,lower_y),(0,0,255), 9) 
                cv2.putText(frame,str(self.angle_final),(point_x2,point_y2-10),0,1,(255,0,0),2)
                return True
        return False
    # ###################################################################################################
    def processNoUSB(self, inframe):
        self.commonProcess(inframe=inframe)
        

    # ###################################################################################################
    ## Process function with USB output
    def process(self, inframe, outframe):
        _, outimg = self.commonProcess(inframe, outframe)
        outframe.sendCv(outimg)
       

   
        
    ## Process function with USB output
    def commonProcess(self, inframe, outframe):

        frame = inframe.getCvBGR()
        frame = circularmask(frame)
        # Start measuring image processing time (NOTE: does not account for input conversion time):
            
        self.timer.start()
        
        pipeline.process(frame)
        

        '''
        Cube
        '''
        hascones = self.find_cone(frame)
        if not hascones:
            hascubes = self.find_cube(frame)
            if not hascubes:
                self.angle_final = 200
            
        
        outimg = frame
        # Write a title:
        cv2.putText(outimg, "JeVois Orientation", (3, 20), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255))
        
        # Write frames/s info from our timer into the edge map (NOTE: does not account for output conversion time):
        fps = self.timer.stop()
        height = outimg.shape[0]
        width = outimg.shape[1]
        cv2.putText(outimg, fps, (3, height - 6), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255,255,255))
        
        # Convert our output image to video output format and send to host over USB:
        results = self.pattern.match(self.timer.stop())
        if(results is not None):
            self.framerate_fps = results.group(1)
            self.CPULoad_pct = results.group(2)
            self.CPUTemp_C = results.group(3)

        
        serialstr = "{%d %.2f %s %s}"%(
            self.frame,
            self.angle_final,
            self.CPULoad_pct,
            self.CPUTemp_C
        )

        jevois.sendSerial(serialstr)

        self.frame += 1
        self.frame %= 999

        return self.angle_final, outimg
        
